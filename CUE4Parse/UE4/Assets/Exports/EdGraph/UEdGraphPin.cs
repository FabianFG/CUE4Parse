using CUE4Parse.UE4.Assets.Readers;
using CUE4Parse.UE4.Objects.Core.i18N;
using CUE4Parse.UE4.Objects.Core.Misc;
using CUE4Parse.UE4.Objects.Engine.EdGraph;
using CUE4Parse.UE4.Objects.UObject;
using CUE4Parse.UE4.Versions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace CUE4Parse.UE4.Assets.Exports.EdGraph;

[JsonConverter(typeof(StringEnumConverter))]
public enum EPinResolveType : byte
{
    OwningNode,
    LinkedTo,
    SubPins,
    ParentPin,
    ReferencePassThroughConnection
};

public class UEdGraphPin : UEdGraphPinReference
{
    /** Name of this pin. */
    public FName PinName;
    /** Index of the pin in the source data structure represented by the graph, INDEX_NONE if not used */
    public int SourceIndex;
    /** Direction of flow of this pin (input or output) */
    public EEdGraphPinDirection Direction;
    public FText? PinFriendlyName;
    /** The tool-tip describing this pin's purpose */
    public string PinToolTip;
    /** The type of information carried on this pin */
    public FEdGraphPinType PinType;
    /** Default value for this pin (used if the pin has no connections), stored as a string */
    public string DefaultValue;
    /** Initial default value (the autogenerated value, to identify if the user has modified the value), stored as a string */
    public string AutogeneratedDefaultValue;
    /** If the default value for this pin should be an object, we store a pointer to it */
    public FPackageIndex DefaultObject;
    /** If the default value for this pin should be an FText, it is stored here. */
    public FText DefaultTextValue;

    /** Set of pins that we are linked to */
    public UEdGraphPinReference?[] LinkedTo = [];
    /** The pins created when a pin is split and hidden */
    public UEdGraphPinReference?[] SubPins = [];
    /** The pin that was split and generated this pin */
    public UEdGraphPinReference? ParentPin;
    /** Pin that this pin uses for passing through reference connection */
    public UEdGraphPinReference? ReferencePassThroughConnection;
    /** Pin name could be changed, so whenever possible it's good to have a persistent GUID identifying Pin to reconstruct Node seamlessly */
    public FGuid PersistentGuid;

    public uint BitField; 

    public UEdGraphPin(FAssetArchive Ar) : base(Ar)
    {
        if (FFrameworkObjectVersion.Get(Ar) >= FFrameworkObjectVersion.Type.PinsStoreFName)
        {
            PinName = Ar.ReadFName();
        }
        else
        {
            PinName = Ar.ReadFString();
        }

        if (!Ar.IsFilterEditorOnly)
        {
            PinFriendlyName = new FText(Ar);
        }

        if (FUE5MainStreamObjectVersion.Get(Ar) >= FUE5MainStreamObjectVersion.Type.EdGraphPinSourceIndex)
        {
            SourceIndex = Ar.Read<int>();
        }

        PinToolTip = Ar.ReadFString();
        Direction = Ar.Read<EEdGraphPinDirection>();
        PinType = new FEdGraphPinType(Ar);
        DefaultValue = Ar.ReadFString();
        AutogeneratedDefaultValue = Ar.ReadFString();
        DefaultObject = new FPackageIndex(Ar);
        DefaultTextValue = new FText(Ar);

        SerializePinArray(Ar, ref LinkedTo, this, EPinResolveType.LinkedTo);

        // SubPin array is owned by a single UObject, so no complexity of keeping LinkedTo synchronized:
        SerializePinArray(Ar, ref SubPins, this, EPinResolveType.SubPins);
        UEdGraphPinReference?[] NoExistingValues = []; // unused for non-owner paths..
        SerializePin(Ar, ref ParentPin, -1, this, EPinResolveType.ParentPin, ref NoExistingValues);
        SerializePin(Ar, ref ReferencePassThroughConnection, -1, this, EPinResolveType.ReferencePassThroughConnection, ref NoExistingValues);

        if (!Ar.IsFilterEditorOnly)
        {
            PersistentGuid = Ar.Read<FGuid>();
            BitField = Ar.Read<uint>();
        }
    }

    public static void SerializePinArray(FAssetArchive Ar, ref UEdGraphPinReference?[] ArrayRef, UEdGraphPinReference? RequestingPin, EPinResolveType ResolveType)
    {
        var arrayNum = Ar.Read<int>();
        ArrayRef = new UEdGraphPinReference[arrayNum];

        for (int PinIdx = 0; PinIdx < arrayNum; ++PinIdx)
        {
            SerializePin(Ar, ref ArrayRef[PinIdx], PinIdx, RequestingPin, ResolveType, ref ArrayRef);
        }
    }

    public static bool SerializePin(FAssetArchive Ar, ref UEdGraphPinReference? PinRef, int ArrayIdx, UEdGraphPinReference? RequestingPin, EPinResolveType ResolveType, ref UEdGraphPinReference?[] OldPins)
    {
        bool bRetVal = true;
        var bNullPtr = Ar.ReadBoolean();
        if (bNullPtr)
        {
            PinRef = null;
            return bRetVal;
        }

        var pinRef = new UEdGraphPinReference(Ar);
        if (ResolveType == EPinResolveType.OwningNode)
        {
            PinRef = new UEdGraphPin(Ar);
        }
        else
        {
            PinRef = pinRef;
        }
        
        return bRetVal;
    }

    public static void SerializeAsOwningNode(FAssetArchive Ar, ref UEdGraphPinReference?[] ArrayRef)
    {
        SerializePinArray(Ar, ref ArrayRef, null, EPinResolveType.OwningNode);
    }
}
