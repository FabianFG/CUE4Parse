using System;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using CUE4Parse.UE4.Assets.Exports.Texture;
using CUE4Parse.UE4.Objects.Core.Math;
using OffiUtils;
using SkiaSharp;

namespace CUE4Parse_Conversion.Textures;

public static class TextureEncoder
{
    public static byte[] Encode(this CTexture bitmap, ETextureFormat format, out string ext)
    {
        //always export float data as HDR
        if (bitmap.IsFloat)
        {
            ext = "hdr";
            return ToHdrBitmap(bitmap);
        }

        switch (format)
        {
            case ETextureFormat.Png:
            {
                ext = "png";
                using var bmp = bitmap.ToSkBitmap();
                using var data = bmp.Encode(SKEncodedImageFormat.Png, 100);
                return data.ToArray();
            }
            case ETextureFormat.Jpeg:
            {
                ext = "jpg";
                using var bmp = bitmap.ToSkBitmap();
                using var data = bmp.Encode(SKEncodedImageFormat.Jpeg, 100);
                return data.ToArray();
            }
            case ETextureFormat.Tga:
                ext = "tga";
                return EncodeTga(bitmap);
            default:
                ext = "unk";
                return [];
            //TODO: ETextureFormat.Dds
        }
    }

    private static byte[] EncodeTga(CTexture bitmap)
    {
        using var skBitmap = bitmap.ToSkBitmap();
        int width = skBitmap.Width;
        int height = skBitmap.Height;
        int pixelDataSize = width * height * 4;
        int totalSize = 18 + pixelDataSize;

        byte[] output = new byte[totalSize];

        //TGA header
        output[2] = 2; // Uncompressed
        output[12] = (byte)(width & 0xFF);
        output[13] = (byte)(width >> 8);
        output[14] = (byte)(height & 0xFF);
        output[15] = (byte)(height >> 8);
        output[16] = 32; // 32-bit
        output[17] = 8;  // 8 bits of alpha

        unsafe
        {
            fixed (byte* ptr = output)
            {
                byte* pixelPtr = ptr + 18; //Start writing after header

                for (int y = height - 1; y >= 0; y--)//TGA stores pixels bottom-up
                {
                    for (int x = 0; x < width; x++)
                    {
                        var color = skBitmap.GetPixel(x, y);
                        *pixelPtr++ = color.Blue;
                        *pixelPtr++ = color.Green;
                        *pixelPtr++ = color.Red;
                        *pixelPtr++ = color.Alpha;
                    }
                }
            }
        }
        return output;
    }

    private static void WriteHdrHeader(Stream stream, int width, int height)
    {
        using var writer = new StreamWriter(stream, Encoding.ASCII, leaveOpen: true);
        writer.WriteLine("#?RADIANCE");
        writer.WriteLine("# Generated by CUE4Parse");
        writer.WriteLine("FORMAT=32-bit_rle_rgbe");
        writer.WriteLine();
        writer.WriteLine($"-Y {height} +X {width}");
        writer.Flush();
    }

    public static byte[] ToHdrBitmap(this CTexture texture)
    {
        var dataSpan = new ReadOnlySpan<byte>(texture.Data);
        nint convertedDataPtr = nint.Zero;

        // Convert the texture data to RGBE format
        switch (texture.PixelFormat)
        {
            case EPixelFormat.PF_FloatRGB:
            case EPixelFormat.PF_FloatRGBA:
                convertedDataPtr = ConvertFloatToRGBE(texture.PixelFormat, texture.Width, texture.Height, dataSpan);
                break;
            case EPixelFormat.PF_R32_FLOAT:
            case EPixelFormat.PF_R32G32B32F:
                convertedDataPtr = ConvertFloatToRGBE(texture.PixelFormat, texture.Width, texture.Height, dataSpan);
                break;
            case EPixelFormat.PF_A32B32G32R32F:
                convertedDataPtr = ConvertFloatToRGBE(texture.PixelFormat, texture.Width, texture.Height, dataSpan, true);
                break;
            default:
                throw new NotImplementedException("Unsupported pixel format: " + texture.PixelFormat);
        }

        if (convertedDataPtr == nint.Zero)
            throw new Exception("Failed to convert texture data to RGBE format.");

        using var stream = new MemoryStream();

        // Write the HDR header
        WriteHdrHeader(stream, texture.Width, texture.Height);

        // Process each scanline directly from convertedDataPtr
        for (int y = 0; y < texture.Height; y++)
        {
            int rowOffset = y * texture.Width * 4;
            WriteScanlineRLE(stream, convertedDataPtr, texture.Width, rowOffset);
        }

        // Free allocated native memory
        MemoryUtils.NativeFree(convertedDataPtr);

        return stream.ToArray();
    }

    private static void WriteScanlineRLE(MemoryStream stream, nint dataPtr, int scanlineWidth, int rowOffset)
    {
        // Write the scanline header (scanline type 2 and width)
        stream.WriteByte(2);
        stream.WriteByte(2);
        stream.WriteByte((byte)(scanlineWidth >> 8));
        stream.WriteByte((byte)(scanlineWidth & 0xFF));

        // Process each channel (RGBA) separately
        for (int channel = 0; channel < 4; channel++)
        {
            WriteChannelRLE(stream, dataPtr, scanlineWidth, rowOffset, channel);
        }
    }

    private static void WriteChannelRLE(MemoryStream stream, nint dataPtr, int scanlineWidth, int rowOffset, int channel)
    {
        int current = 0;

        while (current < scanlineWidth)
        {
            unsafe
            {
                // Try to find a run of identical values for the current channel
                int runLength = 1;

                while (current + runLength < scanlineWidth && runLength < 127 &&
                       Unsafe.ReadUnaligned<byte>((byte*)dataPtr + rowOffset + (current * 4) + channel) ==
                       Unsafe.ReadUnaligned<byte>((byte*)dataPtr + rowOffset + ((current + runLength) * 4) + channel))
                {
                    runLength++;
                }

                // If we found a run of 4 or more identical values, encode the run using RLE
                if (runLength >= 4)
                {
                    stream.WriteByte((byte)(128 + runLength)); // Start of RLE, 128 + runLength
                    stream.WriteByte(Unsafe.ReadUnaligned<byte>((byte*)dataPtr + rowOffset + (current * 4) + channel)); // Value to repeat
                    current += runLength;
                }
                else
                {
                    // If it's not a run, write individual values
                    int nonRunLength = 1;
                    while (current + nonRunLength < scanlineWidth && nonRunLength < 128)
                    {
                        int nextRun = 1;
                        while (current + nonRunLength + nextRun < scanlineWidth && nextRun < 127 &&
                               Unsafe.ReadUnaligned<byte>((byte*)dataPtr + rowOffset + ((current + nonRunLength) * 4) + channel) ==
                               Unsafe.ReadUnaligned<byte>((byte*)dataPtr + rowOffset + ((current + nonRunLength + nextRun) * 4) + channel))
                        {
                            nextRun++;
                        }

                        // Break early if a run is detected
                        if (nextRun >= 4)
                            break;

                        nonRunLength++;
                    }

                    // Write the non-run length values
                    stream.WriteByte((byte)nonRunLength);
                    for (int i = 0; i < nonRunLength; i++)
                    {
                        stream.WriteByte(Unsafe.ReadUnaligned<byte>((byte*)dataPtr + rowOffset + ((current + i) * 4) + channel));
                    }
                    current += nonRunLength;
                }
            }
        }
    }

    private static unsafe nint ConvertFloatToRGBE(EPixelFormat pixelFormat, int width, int height, ReadOnlySpan<byte> inp, bool flipOrder = false)
    {
        const int typeSize = sizeof(float); // 4 bytes per float
        int channelCount = PixelFormatUtils.PixelFormats.First(x => x.UnrealFormat == pixelFormat).NumComponents; // Get channel count based on pixel format

        MemoryUtils.NativeAlloc<byte>(width * height * 4, out var retPtr); // Allocate memory for RGBE

        fixed (byte* inpPtr = inp)
        {
            byte* outPtr = (byte*)retPtr;

            for (int i = 0; i < width * height; i++)
            {
                int pixelOffset = i * channelCount * typeSize;

                // Select channels based on channelCount and flipOrder
                float r = 0, g = 0, b = 0;
                if (flipOrder) // ABGR input
                {
                    if (channelCount > 0) r = *(float*)(inpPtr + pixelOffset + (channelCount > 3 ? 12 : 0)); // Red
                    if (channelCount > 1) g = *(float*)(inpPtr + pixelOffset + (channelCount > 2 ? 8 : 0));  // Green
                    if (channelCount > 2) b = *(float*)(inpPtr + pixelOffset + (channelCount > 1 ? 4 : 0));  // Blue
                }
                else // RGBA input
                {
                    if (channelCount > 0) r = *(float*)(inpPtr + pixelOffset);  // Red
                    if (channelCount > 1) g = *(float*)(inpPtr + pixelOffset + 4);  // Green
                    if (channelCount > 2) b = *(float*)(inpPtr + pixelOffset + 8);  // Blue
                }

                // Find max component for RGBE scaling
                float maxValue = Math.Max(r, Math.Max(g, b));

                byte rByte, gByte, bByte, exponentByte;
                if (maxValue < 1e-32f)
                {
                    rByte = gByte = bByte = exponentByte = 0;
                }
                else
                {
                    int exponent = (int)Math.Floor(Math.Log2(maxValue)) + 1;
                    float scaleFactor = 256.0f / MathF.Pow(2, exponent);

                    rByte = (byte)(r * scaleFactor);
                    gByte = (byte)(g * scaleFactor);
                    bByte = (byte)(b * scaleFactor);
                    exponentByte = (byte)(exponent + 128);
                }

                // Store result in RGBE format
                int idx = i * 4;
                outPtr[idx] = rByte;
                outPtr[idx + 1] = gByte;
                outPtr[idx + 2] = bByte;
                outPtr[idx + 3] = exponentByte;
            }
        }

        return retPtr;
    }


#region SkBitmap

    public static SKBitmap ToSkBitmap(this CTexture texture)
    {
        var dataSpan = new ReadOnlySpan<byte>(texture.Data);
        var convertedData = nint.Zero;

        SKColorType skColorType;

        switch (texture.PixelFormat)
        {
            case EPixelFormat.PF_R8:
                skColorType = SKColorType.Gray8;
                break;
            case EPixelFormat.PF_R8G8B8A8:
                skColorType = SKColorType.Rgba8888;
                break;
            case EPixelFormat.PF_B8G8R8A8:
                skColorType = SKColorType.Bgra8888;
                break;
            case EPixelFormat.PF_FloatRGB:
                convertedData = ConvertFloatTo8<Half>(texture.PixelFormat, texture.Width, texture.Height, dataSpan);
                skColorType = SKColorType.Rgb888x;
                break;
            case EPixelFormat.PF_FloatRGBA:
                convertedData = ConvertFloatTo8<Half>(texture.PixelFormat, texture.Width, texture.Height, dataSpan);
                skColorType = SKColorType.Rgba8888;
                break;
            case EPixelFormat.PF_R32_FLOAT:
            case EPixelFormat.PF_R32G32B32F:
                convertedData = ConvertFloatTo8<float>(texture.PixelFormat, texture.Width, texture.Height, dataSpan);
                skColorType = SKColorType.Rgba8888;
                break;
            case EPixelFormat.PF_A32B32G32R32F:
                convertedData = ConvertFloatTo8<float>(texture.PixelFormat, texture.Width, texture.Height, dataSpan, true);
                skColorType = SKColorType.Rgba8888;
                break;
            case EPixelFormat.PF_A16B16G16R16:
                convertedData = Convert16To8(texture.PixelFormat, texture.Width, texture.Height, dataSpan, true);
                skColorType = SKColorType.Rgba8888;
                break;
            case EPixelFormat.PF_G16:
                convertedData = Convert16To8(texture.PixelFormat, texture.Width, texture.Height, dataSpan);
                skColorType = SKColorType.Rgb888x;
                break;
            case EPixelFormat.PF_G16R16:
                convertedData = Convert16To8(texture.PixelFormat, texture.Width, texture.Height, dataSpan, true);
                skColorType = SKColorType.Rgb888x;
                break;
            default:
                throw new NotImplementedException("Unsupported pixel format: " + texture.PixelFormat);
        }

        var info = new SKImageInfo(texture.Width, texture.Height, skColorType, SKAlphaType.Premul);
        return InstallPixels(dataSpan, convertedData, info);
    }

    private static unsafe nint Convert16To8(EPixelFormat pixelFormat, int width, int height, ReadOnlySpan<byte> inp, bool flipOrder = false)
    {
        int channelCount = PixelFormatUtils.PixelFormats.First(x => x.UnrealFormat == pixelFormat).NumComponents;
        int outputChannelCount = Math.Max(channelCount, 4); // Ensure at least 4 channels (RGBA)

        // Allocate memory without creating an unused Span<byte>
        MemoryUtils.NativeAlloc<byte>(width * height * outputChannelCount, out var retPtr);

        var inpU16 = MemoryMarshal.Cast<byte, ushort>(inp);

        byte* outPtr = (byte*)retPtr;

        for (int i = 0; i < width * height; i++)
        {
            byte value = FColor.Requantize16to8(inpU16[i]);

            for (int c = 0; c < outputChannelCount; c++)
            {
                int channelIndex = flipOrder ? (outputChannelCount - 1 - c) : c;
                outPtr[i * outputChannelCount + c] = channelIndex < channelCount ? value :
                    (channelCount == 1 ? value : byte.MaxValue);
            }
        }

        return retPtr;
    }

    private static unsafe nint ConvertFloatTo8<T>(EPixelFormat pixelFormat, int width, int height, ReadOnlySpan<byte> inp, bool flipOrder = false) where T : struct
    {
        int channelCount = PixelFormatUtils.PixelFormats.First(x => x.UnrealFormat == pixelFormat).NumComponents;
        int typeSize = Unsafe.SizeOf<T>();

        // Allocate memory, but we don't need a Span<byte>
        MemoryUtils.NativeAlloc<byte>(width * height * channelCount, out var retPtr);

        fixed (byte* inpPtr = inp)
        {
            byte* outPtr = (byte*)retPtr;

            for (int i = 0; i < width * height; i++)
            {
                int pixelOffset = i * channelCount * typeSize;
                int idx = i * channelCount;

                for (int c = 0; c < channelCount; c++)
                {
                    int channelIndex = flipOrder ? (channelCount - 1 - c) : c;
                    int channelOffset = pixelOffset + channelIndex * typeSize;

                    float value = typeof(T) switch
                    {
                        Type t when t == typeof(float) => *(float*)(inpPtr + channelOffset),
                        Type t when t == typeof(Half)  => (float)(*(Half*)(inpPtr + channelOffset)),
                        _ => throw new NotSupportedException("Unsupported type")
                    };

                    outPtr[idx + c] = (byte)Math.Clamp(value * 255.0f, 0, byte.MaxValue);
                }
            }
        }

        return retPtr;
    }

    private static SKBitmap InstallPixels(ReadOnlySpan<byte> data, nint pixelsPtr, SKImageInfo info)
    {
        var bitmap = new SKBitmap();
        if (pixelsPtr == nint.Zero)
        {
            var pixelsSpan = MemoryUtils.NativeAlloc<byte>(data.Length, out pixelsPtr);
            data.CopyTo(pixelsSpan);
        }
        bitmap.InstallPixels(info, pixelsPtr, info.RowBytes, static (address, _) => MemoryUtils.NativeFree(address));
        return bitmap;
    }

#endregion

}
